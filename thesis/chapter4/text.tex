% Text for chapter 4
\chapter{synthesizAR: A Framework for Modeling Optically-thin Emission}

% Figure manager for Chapter 3
% spell-checker: disable %
\begin{pycode}[chapter4]
name = 'chapter4'
ch4 = texfigure.Manager(
    pytex,
    os.path.join('.', name),
    number=4,
    **{k: os.path.join('.', name, v) for k,v in manager_opts.items()}
)
from matplotlib.patches import ConnectionPatch
\end{pycode}
% spell-checker: enable %

In order to accurately predict observed optically-thin emission from the impulsively-heated coronal plasma, one must properly account for the field-aligned hydrodynamic response to the energy deposition (\autoref{ch:loops}), the detailed atomic physics that produces the radiation (\autoref{ch:diagnostics}), and geometric effects due to the integration along the LOS. During the course of my PhD, I have a developed a software framework for modeling optically-thin coronal emission called synthesizAR. synthesizAR includes tools for extrapolating the three-dimensional magnetic field from observed LOS magnetograms, configuring input and reading output from ensembles of field-aligned hydrynamic simulations, and computing projections of the emission along the LOS for arbitrary viewing angles. 

synthesizAR is written entirely in the widely-used and open-source Python programming language and developed openly on GitHub\footnote{The entire source code, including installation instructions and links to documentation, can be found at \href{https://github.com/wtbarnes/synthesizAR}{github.com/wtbarnes/synthesizAR}}. synthesizAR is built on top of many of the packages in the mature scientific Python ecosystem, including the scipy package \citep{jones_scipy_2001}, NumPy for array computation \citep{oliphant_guide_2006}, and Astropy \citep{the_astropy_collaboration_astropy_2018}. In particular, synthesizAR depends heavily on SunPy \citep{sunpy_community_sunpypython_2015}, a package for data analysis in solar physics, for manipulating imaging data and solar coordinate transformations.

The code is fully-documented, including examples, and also includes a test suite that is executed at every code check-in. In this chapter, I give a detailed description of each step of an example workflow using synthesizAR, including working code examples throughout, for a simple dipolar \AR{} in hydrostatic equilibrium. In \autoref{ch:modeling_observables}, I use the synthesizAR code coupled with the two-fluid EBTEL code (see \autoref{sec:ebtel}) to model time-dependent, multi-wavelength emission from an \AR{} for a range of nanoflare heating frequencies.

\section{Building the Magnetic Skeleton}

% Magnetic field extrapolations

The first step in the forward modeling pipeline is to determine the three-dimensional geometry of each magnetic strand in order to construct the magnetic ``skeleton'' of our model \AR{}. As noted in \autoref{ch:loops}, a field-aligned hydrodynamic model only computes the evolution of the plasma along a single thermally-isolated strand such that the three-dimensional position and orientation of the strand relative to the solar surface must be imposed externally. In this example, I will model the emission from \AR{} NOAA 12733 as observed by SDO/AIA on 2019 January 24. \autoref{fig:noaa12733-magnetogram} shows the LOS magnetogram as observed by SDO/HMI on 2019 January 24 14:00:22 UTC.

% spell-checker: disable %
\begin{pycode}[chapter4]
# Load the magnetogram
magnetogram = Map(
    os.path.join(ch4.data_dir, 'hmi_m_45s_2019_01_24_14_01_30_tai_magnetogram.fits')
).rotate(order=3)
# Define AR FOV
l_corner = SkyCoord(Tx=-142*u.arcsec,Ty=50*u.arcsec,frame=magnetogram.coordinate_frame)
r_corner = SkyCoord(Tx=158*u.arcsec,Ty=350*u.arcsec,frame=magnetogram.coordinate_frame)

# Mask the magnetogram off limb
x, y = np.meshgrid(*[np.arange(v.value) for v in magnetogram.dimensions]) * u.pixel
hpc_coords = magnetogram.pixel_to_world(x, y)
r = np.sqrt(hpc_coords.Tx ** 2 + hpc_coords.Ty ** 2) / magnetogram.rsun_obs
mask = np.ma.masked_greater(r, 1)
m_big = Map(magnetogram.data, magnetogram.meta, mask=mask.mask)

# Setup figure
fig = plt.figure(figsize=texfigure.figsize(pytex,scale=1,height_ratio=1.2/2,))
norm = matplotlib.colors.SymLogNorm(50, vmin=-7.5e2, vmax=7.5e2)

# Plot the first magnetogram
ax1 = fig.add_subplot(121, projection=m_big)
m_big.plot(axes=ax1, cmap='better_RdBu_r', norm=norm, annotate=False,)
lon,lat = ax1.coords[0], ax1.coords[1]
lon.frame.set_linewidth(0)
lat.frame.set_linewidth(0)
lon.set_ticks_visible(False)
lat.set_ticks_visible(False)
lon.set_ticklabel_visible(False)
lat.set_ticklabel_visible(False)
m_big.draw_rectangle(l_corner, r_corner.Tx-l_corner.Tx, r_corner.Ty-l_corner.Ty, color='k', lw=1)
m_big.draw_grid(axes=ax1, color='k', alpha=0.25, lw=0.5)

# Plot the zoomed-in magnetogram
m_small = magnetogram.submap(l_corner, r_corner)
ax2 = fig.add_subplot(122, projection=m_small)
im = m_small.plot(axes=ax2, norm=norm, cmap='better_RdBu_r',annotate=False,)
ax2.grid(alpha=0)
lon, lat = ax2.coords[0], ax2.coords[1]
lon.frame.set_linewidth(1)
lat.frame.set_linewidth(1)
lon.set_ticklabel()
lat.set_ticklabel(rotation='vertical',)
lon.set_axislabel('Helioprojective Longitude',)
lat.set_axislabel('Helioprojective Latitude',)
lat.set_axislabel_position('r')
lat.set_ticks_position('r')
lat.set_ticklabel_position('r')

# Add connectors
xpix, ypix = m_big.world_to_pixel(r_corner)
con1 = ConnectionPatch(
    (0,1), (xpix.value, ypix.value), 'axes fraction', 'data', axesA=ax2, axesB=ax1,
    arrowstyle='-', color='k', lw=1
)
xpix, ypix = m_big.world_to_pixel(SkyCoord(r_corner.Tx, l_corner.Ty, frame=m_big.coordinate_frame))
con2 = ConnectionPatch(
    (0,0), (xpix.value,ypix.value), 'axes fraction', 'data', axesA=ax2, axesB=ax1,
    arrowstyle='-', color='k', lw=1
)
ax2.add_artist(con1)
ax2.add_artist(con2)

# Add colorbar
pos = ax2.get_position().get_points()
cax = fig.add_axes([
    pos[0,0], pos[1,1]+0.01, pos[1,0]-pos[0,0], 0.025
])
cbar = fig.colorbar(im, cax=cax, orientation='horizontal')
cbar.locator = matplotlib.ticker.FixedLocator([-1e2,0,1e2])
cbar.update_ticks()
cbar.ax.xaxis.set_ticks_position('top')

# Save figure
tfig = ch4.save_figure('noaa12733-magnetogram', fext='.pdf')
tfig.caption = r'HMI LOS magnetogram observed on 2019 January 24 14:00:22 UTC. The full-disk observation is shown on the left and the zoomed-in view of NOAA 12733 is shown on the right. In both panels, the colorbar is on a symlog scale from \SI{-750}{\gauss} to \SI{750}{\gauss}. Note that at the time of this observation, the \AR{} was close to the center of the disk.'
\end{pycode}
\py[chapter4]|tfig|
% spell-checker: enable %

\subsection{Potential Field Extrapolation}\label{sec:potential_field}

As discussed in \autoref{sec:field_extrapolation}, a potential field extrapolation provides a reasonable approximation of the lowest energy configuration of the coronal magnetic field and can be computed relatively efficiently given an input LOS photospheric magnetogram as the lower boundary. On the scale of a single \AR{}, the curvature of the solar surface can be ignored and  the problem reduces to solving Laplace's equation (\autoref{eq:laplace}) on a Cartesian grid, with the $z$-axis pointed toward the observer, given the boundary conditions,
\begin{align}\label{eq:potential_bcs}
    &-\mathbf{n}\cdot\nabla\phi = B_z(x,y,0), \\
    &\phi(\mathbf{r})\to0 \enspace \textup{as} \enspace \mathbf{r}\to\infty,
\end{align}
where $\mathbf{n}$ is the unit vector in the $z$-direction and $B_z(x,y,0)$ is the $z$-component of the magnetic field at the photosphere given by the observed LOS magnetogram \citep{sakurai_greens_1982}.

Following the method of \citet{schmidt_observable_1964} as outlined by \citet{sakurai_greens_1982}, the Green's function, $G$, for this problem must satisfy the conditions,
\begin{align}
    &\nabla^2G(\mathbf{r},\mathbf{r}^\prime) = 0, \nonumber \\
    &G(\mathbf{r},\mathbf{r}^\prime) \to 0 \enspace \textup{as} \enspace |\mathbf{r}-\mathbf{r}^\prime|\to\infty, \nonumber \\
    &-\mathbf{n}\cdot\nabla G(\mathbf{r},\mathbf{r}^\prime) = 0, \nonumber
\end{align} 
where $\mathbf{r}^\prime=(x^\prime,y^\prime,0)$ is the position on the $z=0$ plane and the gradient is taken with respect to $\mathbf{r}$. Integrating this Green's function over the boundary weighted by the observed field strength gives a solution for $\phi$,
\begin{equation}\label{eq:bv_solution}
    \phi(\mathbf{r}) = \int\dd{x^\prime}\dd{y^\prime}B_z(\mathbf{r}^\prime)G(\mathbf{r},\mathbf{r}^\prime),
\end{equation}
and the magnetic field is computed trivially from \autoref{eq:b_potential} using a finite-difference scheme. The Green's function in \autoref{eq:bv_solution} has the form,
\begin{equation}\label{eq:greens}
    G = \frac{1}{2\pi|\mathbf{r} - \mathbf{r}^\prime|}.
\end{equation}
\citet{schmidt_observable_1964} suggest an ``oblique'' correction to $G$ for cases where the \AR{} is far from disk center and $\mathbf{n}$, the surface normal, is not aligned with the unit vector pointing toward the observer, $\bm{\ell}$. In this case, the modified Green's function is,
\begin{equation}\label{eq:greens_oblique}
    G = \frac{1}{2\pi}\left[\frac{\mathbf{n}\cdot\bm{\ell}}{|\mathbf{r} - \mathbf{r}^\prime|} + \frac{(\bm{\ell}\times(\mathbf{n}\times\bm{\ell}))\cdot\mathbf{R}}{R(R + \bm{\ell}\cdot\mathbf{R})} \right]
\end{equation}
where $\mathbf{R}=\mathbf{r} - \mathbf{r}^\prime$. Note that if $\bm{\ell}=\mathbf{n}$, \autoref{eq:greens_oblique} reduces to \autoref{eq:greens}. The second term in \autoref{eq:greens_oblique} corresponds to a line of dipoles extending out to $z\to\infty$ in order to compensate for a reduction in the first term due to the projection of $\mathbf{n}$ on $\bm{\ell}$ \citep{sakurai_greens_1982}.

The oblique extrapolation method of \citet{schmidt_observable_1964} is implemented in synthesizAR and can easily be used to compute $\mathbf{B}$ above an \AR{},
% spell-checker: disable %
\begin{pycode}[chapter4]
m_ar = magnetogram.submap(l_corner, r_corner)
\end{pycode}
\begin{pyblock}[chapter4][baselinestretch=1,xleftmargin=3em]
from synthesizAR.extrapolate import PotentialField
m_ar_resampled = m_ar.resample([100, 100] * u.pixel)
n_z = 100 * u.pixel
w_z = 215 * u.Mm
extrapolator = PotentialField(m_ar_resampled, w_z, n_z)
B_field = extrapolator.extrapolate()
\end{pyblock}
% spell-checker: enable %
\pyb[chapter4]|m_ar| is a \pyb[chapter4]|Map| object provided by SunPy that includes both the data and associated metadata of the HMI LOS magnetogram cropped to the area around NOAA 12733 as shown in the right panel of \autoref{fig:noaa12733-magnetogram}. The magnetogram is resampled to a lower resolution to reduce the computational cost of the field extrapolation. The method call in the last line computes $\mathbf{B}$ using the Green's function in \autoref{eq:greens_oblique} and the observed magnetogram as $B_z(x,y,0)$ and returns an object containing a $100\times100\times100$ array for each component of $\mathbf{B}$. \autoref{fig:extrapolation-slice} shows a slice along the $y$-axis through the center of the extrapolated volume of $B_x$.

% spell-checker: disable %
\begin{pycode}[chapter4]
# Extract yt dataset and grid
ds = extrapolator.as_yt(B_field)
sli = ds.slice('y', ds.domain_left_edge[1].value+ds.domain_width[1].value/2)
frb = sli.to_frb(ds.domain_width[0], ds.domain_dimensions[[0,2]])
x,z = np.meshgrid(
    np.linspace(
        ds.domain_left_edge[0].value,
        ds.domain_right_edge[0].value,
        ds.domain_dimensions[0]),
    np.linspace(
        ds.domain_left_edge[2].value,
        ds.domain_right_edge[2].value,
        ds.domain_dimensions[2])
)
x = x*u.cm
z = z*u.cm

# Setup figure
fig = plt.figure(figsize=texfigure.figsize(pytex,scale=0.75,height_ratio=0.95,))
ax = fig.gca()
# Plot image
im = ax.pcolormesh(
    x.to(u.Mm), z.to(u.Mm),
    np.array(frb['Bx']).T,
    cmap='better_RdBu_r',
    norm=matplotlib.colors.SymLogNorm(5,vmin=-7.5e2,vmax=7.5e2)
)
# Plot streamlines
ax.streamplot(
    x.to(u.Mm).value, z.to(u.Mm).value,
    np.array(frb['Bx']).T, np.array(frb['Bz']).T,
    color='k', linewidth=1, density=1, arrowstyle='fancy'
)
# Limits and labels
ax.set_xlim(x.to(u.Mm)[0,:][[0,-1]].value)
ax.set_ylim(z.to(u.Mm)[:,0][[0,-1]].value)
ax.set_xlabel(r'$x$ $[\si{\mega\m}]$')
ax.set_ylabel(r'$z$ $[\si{\mega\m}]$')
# Colorbar
pos = ax.get_position().get_points()
cbar = fig.colorbar(
    im,
    fig.add_axes([pos[1,0]+0.01, pos[0,1], 0.03, pos[1,1]-pos[0,1]]),
    orientation='vertical',
)
cbar.locator = matplotlib.ticker.FixedLocator([-1e2, 0, 1e2])
cbar.update_ticks()
# Save figure
tfig = ch4.save_figure('extrapolation-slice', fext='.pdf')
tfig.caption = r'A slice through the center of the extrapolated volume of $B_x$ along the $y$-axis. The black streamlines indicate the $B_x$ and $B_z$ components of the field at this slice. The colorbar is on a log scale and ranges from \SI{-750 }{\gauss} to \SI{750 }{\gauss}.'
tfig.figure_width = r'0.75\textwidth'
\end{pycode}
\py[chapter4]|tfig|
% spell-checker: enable %

\subsection{Tracing Magnetic Fieldlines}\label{sec:trace-fieldlines}

Now that the vector magnetic field has been computed from the observed LOS magnetogram, the next step in the pipeline is to trace magnetic fieldlines through the extrapolated volume in order to obtain three-dimensional coordinates for each of the magnetic strands. synthesizAR wraps the low-level streamline tracing capabilities of yt, a Python package for manipulating large, high-dimensional datasets \citep{turk_yt_2011}. This is encapsulated in a method attached to the \pyv{PotentialField} object instantiated above,
% spell-checker: disable %
\begin{pyblock}[chapter4][baselinestretch=1,xleftmargin=3em]
strands = extrapolator.trace_fieldlines(
    B_field, 200, loop_length_range=[20,250]*u.Mm)
\end{pyblock}
% spell-checker: enable %
This traces 200 fieldlines through the extrapolated volume and returns a list of field strengths and three-dimensional coordinates along the strand for each of the 200 traced fieldlines. By default, synthesizAR places seed points for the fieldline tracing on the lower boundary in areas of relatively high magnetic field strength though this parameter can be adjusted. Additionally, only strands whose footpoints are both connected to the surface (closed field) and whose loop lengths fall within the specified range (as shown above) are kept.

The last step is to create the magnetic ``skeleton'' object from the traced fieldlines,
% spell-checker: disable %
\begin{pyblock}[chapter4][baselinestretch=1,xleftmargin=3em]
from synthesizAR import Field
noaa12733 = Field(m_ar_resampled, strands)
\end{pyblock}
% spell-checker: enable %
The \pyv{Field} object holds all of the information about each of the magnetic strands. When the \pyv{Field} object is created, a \pyv{Loop} object is created for each strand. These are accessible through the \pyv{.loops} attribute on the \pyv{Field} object. Each \pyv{Loop} object holds several attributes related to the properties of that strand
% spell-checker: disable %
\begin{pyblock}[chapter4][baselinestretch=1,xleftmargin=3em]
noaa12733.loops  # list of all strands
noaa12733.loops[0]  # access the first strand
noaa12733.loops[0].coordinates  # access the 3D positions
noaa12733.loops[0].full_length  # footpoint-to-footpoint length
noaa12733.loops[0].field_strength  # |B| along the streamline
\end{pyblock}
% spell-checker: enable %
This construction provides an intuitive interface for investigating the properties of the \AR{}. \autoref{fig:magnetogram-with-strands} shows all 200 strands traced from the extrapolated volume overlaid on the observed magnetogram of NOAA 12733. 

% spell-checker: disable %
\begin{pycode}[chapter4]
fig = plt.figure(figsize=texfigure.figsize(pytex,scale=0.65,height_ratio=1,))
ax = fig.gca(projection=m_ar)
m_ar.plot(axes=ax, annotate=False, cmap='better_RdBu_r',
          norm=matplotlib.colors.SymLogNorm(50, vmin=-7.5e2, vmax=7.5e2))
ax.grid(alpha=0)
lon,lat = ax.coords[0], ax.coords[1]
lon.set_axislabel('Helioprojective Longitude')
lat.set_axislabel('Helioprojective Latitude')
for l in noaa12733.loops:
    coord = l.coordinates.transform_to(m_ar.coordinate_frame)
    ax.plot_coord(coord, ls='-', lw=1, color='k', alpha=0.5)
tfig = ch4.save_figure('magnetogram-with-strands', fext='.pdf')
tfig.caption = r'LOS magnetogram of NOAA 12733 as observed by SDO/HMI. All 200 traced fieldlines are overlaid in black.'
tfig.figure_width = r'0.65\textwidth'
\end{pycode}
\py[chapter4]|tfig|
% spell-checker: enable %

\subsection{Aside: Coordinate Systems in Solar Physics}\label{sec:coordinates}

The extrapolated magnetic field is represented in a Cartesian coordinate system where the origin is at the center of the \AR{}, the $z$-axis is normal to the surface, and the $y$-axis points toward solar north. The coordinates in this local \AR{} frame can be defined in terms of the Heliocentric Earth equatorial (HEEQ) Cartesian coordinate system of \citet{hapgood_space_1992},
\begin{equation}\label{eq:local_heeq_transform}
    \begin{pmatrix}x_\textup{HEEQ} \\ y_\textup{HEEQ} \\ z_\textup{HEEQ}\end{pmatrix}
    = \mathbf{R}_z(\Phi_\textup{AR})\mathbf{R}_y(-\Theta_\textup{AR})
    \begin{pmatrix}z_\textup{local} \\ x_\textup{local} \\ y_\textup{local}\end{pmatrix},
\end{equation}
where $x_\textup{local}$, $y_\textup{local}$, $z_\textup{local}$ are the coordinates in the local \AR{} frame, $x_\textup{HEEQ}$, $y_\textup{HEEQ}$, $z_\textup{HEEQ}$ are the coordinates in the HEEQ frame, $\mathbf{R}_{y,z}$ are the rotation matrices about the $y$ and $z$ axes, and $\Phi_\textup{AR}$ and $\Theta_\textup{AR}$ are the longitude and latitude of the center of the \AR{}, respectively.

The HEEQ Cartesian coordinate system is defined such that the $z$-axis is the solar rotation axis and increases towards solar north, and the $x$-axis points from the center of the Sun to the intersection between the solar equator and the central meridian as seen from Earth. The longitude and latitude in \autoref{eq:local_heeq_transform} are defined in the Stonyhurst heliographic (HGS) coordinate system which can be defined in HEEQ coordinates as,
\begin{align}\label{eq:heeq_hgs_transform}
    r &= \sqrt{x^2_\textup{HEEQ} + y^2_\textup{HEEQ} + z^2_\textup{HEEQ}}, \\
    \Theta &= \arctan{\left(\frac{z_\textup{HEEQ}}{\sqrt{x^2_\textup{HEEQ} + y^2_\textup{HEEQ}}}\right)}, \\
    \Phi &= \arctan{\left(\frac{y_\textup{HEEQ}}{x_\textup{HEEQ}}\right)},
\end{align}
where $r$ is the radial distance, measured in units of physical distance, from the center of the Sun and $\Phi$ and $\Theta$ are the angles of longitude and latitude, respectively, as measured from origin \citep{thompson_coordinate_2006}. Note that both the HEEQ and HGS coordinate systems are defined such that they remained fixed with respect to the Earth.

% spell-checker: disable %
\begin{pycode}[chapter4]
data = np.zeros((10, 10))
lon, lat = 0*u.deg, 0*u.deg
time_now = astropy.time.Time.now()
meta = {
    'ctype1': 'HPLN-TAN',
    'ctype2': 'HPLT-TAN',
    'cunit1': 'arcsec',
    'cunit2': 'arcsec',
    'crpix1': (data.shape[0] + 1)/2.,
    'crpix2': (data.shape[1] + 1)/2.,
    'cdelt1': 1.0,
    'cdelt2': 1.0,
    'crval1': 0.0,
    'crval2': 0.0,
    'hgln_obs': lon.to(u.deg).value,
    'hglt_obs': lat.to(u.deg).value,
    'dsun_obs': const.au.to(u.m).value,
    'dsun_ref': const.au.to(u.m).value,
    'rsun_ref': const.R_sun.to(u.m).value,
    'rsun_obs': ((const.R_sun/const.au).decompose()*u.radian).to(u.arcsec).value,
    't_obs': time_now.iso,
    'date-obs': time_now.iso,
}
dummy_map = GenericMap(data, meta)
# Plot coordinates
fig = plt.figure(figsize=texfigure.figsize(pytex,scale=0.65,height_ratio=1,))
ax = fig.gca(projection=dummy_map)
dummy_map.plot(alpha=0, axes=ax, annotate=False)
ax.plot_coord(
    SkyCoord(*[-1000,-1000]*u.arcsec, frame=dummy_map.coordinate_frame),
    color='w',alpha=0,
)
ax.plot_coord(
    SkyCoord(*[1000,1000]*u.arcsec, frame=dummy_map.coordinate_frame),
    color='w',alpha=0,
)
lon,lat = ax.coords[0],ax.coords[1]
lon.grid(color='k', alpha=0.75, linestyle='solid', lw=1)
lat.grid(color='k', alpha=0.75, linestyle='solid', lw=1)
lon.frame.set_linewidth(0)
lat.frame.set_linewidth(0)
dummy_map.draw_grid(axes=ax, grid_spacing=10*u.deg, color=PALETTE[0], lw=1.5, alpha=0.35)
lon.set_ticks_visible(False)
lat.set_ticks_visible(False)
lon.set_ticks(spacing=250*u.arcsec)
lat.set_ticks(spacing=250*u.arcsec)
lon.set_ticklabel_visible(False)
lat.set_ticklabel_visible(False)
# Save figure
tfig = ch4.save_figure('hpc-hgs-grid', fext='.pdf')
tfig.caption = r'Helioprojective coordinate system (black) overlaid on a Stonyhurst heliographic coordinate system (blue) as viewed by an observer at $(\SI{0}{\degree},\SI{0}{\degree},\num{1}\,\textup{AU})$. The spacing between the lines of HGS longitude and latitude is \SI{10}{\degree} and the spacing between the lines of HPC longitude and latitude is \SI{250}{\arcsecond}.'
tfig.figure_width = r'0.65\textwidth'
\end{pycode}
\py[chapter4]|tfig|
% spell-checker: enable %

Though the HGS frame provides an intuitive way for representing coordinates on the Sun, real data represent projections of the Sun on the celestial sphere such that the data must be represented in a \textit{projected} coordinate system defined by the position of the observer (e.g. a satellite, Earth). Following \citet{thompson_coordinate_2006}, the helioprojective (HPC) coordinate system is defined in terms of the longitude and latitude on the celestial sphere centered on the Sun-observer line. The transformation between the HPC frame and the heliocentric cartesian (HCC) coordinate frame is given by,
\begin{align}\label{eq:hcc_hpc_transform}
    &d = \sqrt{x^2 + y^2  + (D_{\solar} - z)^2}, \\
    &\theta_x = \arctan{\left(\frac{x}{D_{\solar} - z}\right)}, \\
    &\theta_y = \arcsin{\left(\frac{y}{d}\right)},
\end{align}
where $d$ is the radial distance from the observer, $D_{\solar}$ is the distance between the observer and the center of the Sun, and $x,y,z$ are the coordinates in the HCC frame. The $z$-axis of the HCC frame is oriented along the Sun-observer line and the $y$-axis points toward solar north. The transformation between the HGS and HCC frame is given by,
\begin{align}\label{eq:hgs_hcc_transform}
    &x = r\cos{\Theta}\sin{(\Phi - \Phi_0)}, \\
    &y = r\left( \sin{\Theta}\cos{B_0} - \cos{\Theta}\cos{(\Phi - \Phi_0)}\sin{B_0} \right), \\
    &z = r\left( \sin{\Theta}\sin{B_0} + \cos{\Theta}\cos{(\Phi - \Phi_0)}\cos{B_0} \right),
\end{align}
where $\Phi_0$ and $B_0$ are the HGS longitude and latitude of the observer. Note that unlike the HGS frame, the HPC and HCC frames are defined in terms of an observer at a particular location. \autoref{fig:hpc-hgs-grid} shows a comparison between the HGS frame and a HPC frame defined by an observer at $\Phi=\SI{0}{\degree}$, $\Theta=\SI{0}{\degree}$, and distance of \num{1} AU. 

After the fieldlines are traced through the extrapolated volume, synthesizAR transforms the coordinates of each strand to HEEQ coordinates (using \autoref{eq:local_heeq_transform}) and returns an Astropy \pyv{SkyCoord} objects. These are stored in the \pyv{.coordinates} attributed of each \pyv{Loop} object in the magnetic skeleton. A \pyv{SkyCoord} object stores the numerical values of the coordinates as well as the frame of reference in which the coordinates are defined such that coordinates can easily be represented different frames. SunPy provides representations of and transformations between many of the common solar coordinate systems as described by \citet{thompson_coordinate_2006}. For example, to define a point \pyv{p} on the surface of the Sun at \SI{20}{\degree} longitude and \SI{20}{\degree} latitude and then transform it to a HPC coordinate system defined by an observer on Earth,
% spell-checker: disable %
\begin{pyblock}[][baselinestretch=1,xleftmargin=3em]
from sunpy.coordinates import Helioprojective
p = SkyCoord(lon=20*u.deg, lat=20*u.deg, radius=const.R_sun,
             frame='heliographic_stonyhurst')
hpc_frame = Helioprojective(
    observer='Earth', obstime=astropy.time.Time.now())
p_hpc = p.transform_to(hpc_frame)
\end{pyblock}
% spell-checker: enable %
Representing the coordinates of each strand in this way makes it simple to compute projections of the magnetic skeleton for any viewing angle. For example, in \autoref{fig:magnetogram-with-strands}, the coordinates of each strand are transformed to a HPC coordinate system defined by an observer at the position of the SDO spacecraft on 2019 January 24 14:00:22 UTC.

\section{Field-aligned Modeling}

% interface configurable; use Martens
% run loop calculation
% show sample loop results for subset of loops

\section{Atomic Physics}

% Choose Fe XVIII (94), XVIII (131) XIV (211), and XVI (335)

\section{Instrument Effects}

\subsection{LOS Projection}
