% Text for chapter 4
\chapter{synthesizAR: A Framework for Modeling Optically-thin Emission}

% Figure manager for Chapter 3
% spell-checker: disable %
\begin{pycode}[chapter4]
name = 'chapter4'
ch4 = texfigure.Manager(
    pytex,
    os.path.join('.', name),
    number=4,
    **{k: os.path.join('.', name, v) for k,v in manager_opts.items()}
)
from matplotlib.patches import ConnectionPatch
\end{pycode}
% spell-checker: enable %

In order to accurately predict observed optically-thin emission from the impulsively-heated coronal plasma, one must properly account for the field-aligned hydrodynamic response to the energy deposition (\autoref{ch:loops}), the detailed atomic physics that produces the radiation (\autoref{ch:diagnostics}), and geometric effects due to the integration along the LOS. During the course of my PhD, I have a developed a software framework for modeling optically-thin coronal emission called synthesizAR\footnote{The name derives from the words ``synthesize'' and the common abbreviation for \AR{}, ``AR'' as the code was built to predict, or synthesize, emission from \AR s. synthesizAR is also a homophone of synthesizer.}. synthesizAR includes tools for extrapolating the three-dimensional magnetic field from observed LOS magnetograms, configuring input and reading output from ensembles of field-aligned hydrynamic simulations, and computing projections of the emission along the LOS for arbitrary viewing angles. 

synthesizAR is written entirely in the widely-used and open-source Python programming language and developed openly on GitHub\footnote{The entire source code, including installation instructions and links to documentation, can be found at \href{https://github.com/wtbarnes/synthesizAR}{github.com/wtbarnes/synthesizAR}}. synthesizAR is built on top of many of the packages in the mature scientific Python ecosystem, including the scipy \citep{jones_scipy_2001} for general numerical and scientific computation, NumPy for array computation \citep{oliphant_guide_2006}, and Astropy \citep{the_astropy_collaboration_astropy_2018}. In particular, synthesizAR depends heavily on SunPy \citep{sunpy_community_sunpypython_2015}, a package for data analysis in solar physics, for manipulating imaging data and solar coordinate transformations.

The code is fully-documented, including examples, and also includes a test suite that is executed at every code check-in. In this chapter, I give a detailed description of each step of an example workflow using synthesizAR, including working code examples throughout, for a simple dipolar \AR{} in hydrostatic equilibrium. In \autoref{ch:modeling_observables}, I use the synthesizAR code coupled with the two-fluid EBTEL code (see \autoref{sec:ebtel}) to model time-dependent, multi-wavelength emission from an \AR{} for a range of nanoflare heating frequencies. While similar approaches have been used in the past to model optically-thin coronal X-ray and EUV emission \citep[e.g.][]{warren_hydrostatic_2006,schrijver_coronal_2004,lundquist_forward_2008,lundquist_forward_2008-1,bradshaw_patterns_2016,allred_3d_2018}, the synthesizAR package represents the first effort to organize this forward modeling pipeline into an openly-developed and easily-configurable codebase that leverages the high-quality software developed by the greater scientific Python and astronomy communities.

\section{Building the Magnetic Skeleton}

The first step in the forward modeling pipeline is to determine the three-dimensional geometry of each magnetic strand in order to construct the magnetic ``skeleton'' of our model \AR{}. As noted in \autoref{ch:loops}, a field-aligned hydrodynamic model only computes the evolution of the plasma along a single thermally-isolated strand such that the three-dimensional position and orientation of the strand relative to the solar surface must be imposed externally. In this example, I will model the emission from \AR{} NOAA 12733 as observed by SDO/AIA on 2019 January 24. \autoref{fig:noaa12733-magnetogram} shows the LOS magnetogram as observed by SDO/HMI on 2019 January 24 14:00:22 UTC.

% spell-checker: disable %
\begin{pycode}[chapter4]
# Load the magnetogram
magnetogram = Map(
    os.path.join(ch4.data_dir, 'hmi_m_45s_2019_01_24_14_01_30_tai_magnetogram.fits')
).rotate(order=3)
# Define AR FOV
l_corner = SkyCoord(Tx=-142*u.arcsec,Ty=50*u.arcsec,frame=magnetogram.coordinate_frame)
r_corner = SkyCoord(Tx=158*u.arcsec,Ty=350*u.arcsec,frame=magnetogram.coordinate_frame)

# Mask the magnetogram off limb
x, y = np.meshgrid(*[np.arange(v.value) for v in magnetogram.dimensions]) * u.pixel
hpc_coords = magnetogram.pixel_to_world(x, y)
r = np.sqrt(hpc_coords.Tx ** 2 + hpc_coords.Ty ** 2) / magnetogram.rsun_obs
mask = np.ma.masked_greater(r, 1)
m_big = Map(magnetogram.data, magnetogram.meta, mask=mask.mask)

# Setup figure
fig = plt.figure(figsize=texfigure.figsize(pytex,scale=1,height_ratio=1.2/2,))
norm = matplotlib.colors.SymLogNorm(50, vmin=-7.5e2, vmax=7.5e2)

# Plot the first magnetogram
ax1 = fig.add_subplot(121, projection=m_big)
m_big.plot(axes=ax1, cmap='better_RdBu_r', norm=norm, annotate=False,)
lon,lat = ax1.coords[0], ax1.coords[1]
lon.frame.set_linewidth(0)
lat.frame.set_linewidth(0)
lon.set_ticks_visible(False)
lat.set_ticks_visible(False)
lon.set_ticklabel_visible(False)
lat.set_ticklabel_visible(False)
m_big.draw_rectangle(l_corner, r_corner.Tx-l_corner.Tx, r_corner.Ty-l_corner.Ty, color='k', lw=1)
m_big.draw_grid(axes=ax1, color='k', alpha=0.25, lw=0.5)

# Plot the zoomed-in magnetogram
m_small = magnetogram.submap(l_corner, r_corner)
ax2 = fig.add_subplot(122, projection=m_small)
im = m_small.plot(axes=ax2, norm=norm, cmap='better_RdBu_r',annotate=False,)
ax2.grid(alpha=0)
lon, lat = ax2.coords[0], ax2.coords[1]
lon.frame.set_linewidth(1)
lat.frame.set_linewidth(1)
lon.set_ticklabel()
lat.set_ticklabel(rotation='vertical',)
lon.set_axislabel('Helioprojective Longitude',)
lat.set_axislabel('Helioprojective Latitude',)
lat.set_axislabel_position('r')
lat.set_ticks_position('r')
lat.set_ticklabel_position('r')

# Add connectors
xpix, ypix = m_big.world_to_pixel(r_corner)
con1 = ConnectionPatch(
    (0,1), (xpix.value, ypix.value), 'axes fraction', 'data', axesA=ax2, axesB=ax1,
    arrowstyle='-', color='k', lw=1
)
xpix, ypix = m_big.world_to_pixel(SkyCoord(r_corner.Tx, l_corner.Ty, frame=m_big.coordinate_frame))
con2 = ConnectionPatch(
    (0,0), (xpix.value,ypix.value), 'axes fraction', 'data', axesA=ax2, axesB=ax1,
    arrowstyle='-', color='k', lw=1
)
ax2.add_artist(con1)
ax2.add_artist(con2)

# Add colorbar
pos = ax2.get_position().get_points()
cax = fig.add_axes([
    pos[0,0], pos[1,1]+0.01, pos[1,0]-pos[0,0], 0.025
])
cbar = fig.colorbar(im, cax=cax, orientation='horizontal')
cbar.locator = matplotlib.ticker.FixedLocator([-1e2,0,1e2])
cbar.update_ticks()
cbar.ax.xaxis.set_ticks_position('top')

# Save figure
tfig = ch4.save_figure('noaa12733-magnetogram', fext='.pdf')
tfig.caption = r'HMI LOS magnetogram observed on 2019 January 24 14:00:22 UTC. The full-disk observation is shown on the left and the zoomed-in view of NOAA 12733 is shown on the right. In both panels, the colorbar is on a symlog scale from \SI{-750}{\gauss} to \SI{750}{\gauss}. Note that at the time of this observation, the \AR{} was close to the center of the disk.'
\end{pycode}
\py[chapter4]|tfig|
% spell-checker: enable %

\subsection{Potential Field Extrapolation}\label{sec:potential_field}

As discussed in \autoref{sec:field_extrapolation}, a potential field extrapolation provides a reasonable approximation of the lowest energy configuration of the coronal magnetic field and can be computed relatively efficiently given an input LOS photospheric magnetogram as the lower boundary. On the scale of a single \AR{}, the curvature of the solar surface can be ignored and  the problem reduces to solving Laplace's equation (\autoref{eq:laplace}) on a Cartesian grid, with the $z$-axis pointed toward the observer, given the boundary conditions,
\begin{align}\label{eq:potential_bcs}
    &-\mathbf{n}\cdot\nabla\phi = B_z(x,y,0), \\
    &\phi(\mathbf{r})\to0 \enspace \textup{as} \enspace \mathbf{r}\to\infty,
\end{align}
where $\mathbf{n}$ is the unit vector in the $z$-direction and $B_z(x,y,0)$ is the $z$-component of the magnetic field at the photosphere given by the observed LOS magnetogram \citep{sakurai_greens_1982}.

Following the method of \citet{schmidt_observable_1964} as outlined by \citet{sakurai_greens_1982}, the Green's function, $G$, for this problem must satisfy the conditions,
\begin{align}
    &\nabla^2G(\mathbf{r},\mathbf{r}^\prime) = 0, \nonumber \\
    &G(\mathbf{r},\mathbf{r}^\prime) \to 0 \enspace \textup{as} \enspace |\mathbf{r}-\mathbf{r}^\prime|\to\infty, \nonumber \\
    &-\mathbf{n}\cdot\nabla G(\mathbf{r},\mathbf{r}^\prime) = 0, \nonumber
\end{align} 
where $\mathbf{r}^\prime=(x^\prime,y^\prime,0)$ is the position on the $z=0$ plane and the gradient is taken with respect to $\mathbf{r}$. Integrating this Green's function over the boundary weighted by the observed field strength gives a solution for $\phi$,
\begin{equation}\label{eq:bv_solution}
    \phi(\mathbf{r}) = \int\dd{x^\prime}\dd{y^\prime}B_z(\mathbf{r}^\prime)G(\mathbf{r},\mathbf{r}^\prime),
\end{equation}
and the magnetic field is computed trivially from \autoref{eq:b_potential} using a finite-difference scheme. The Green's function in \autoref{eq:bv_solution} has the form,
\begin{equation}\label{eq:greens}
    G = \frac{1}{2\pi|\mathbf{r} - \mathbf{r}^\prime|}.
\end{equation}
\citet{schmidt_observable_1964} suggest an ``oblique'' correction to $G$ for cases where the \AR{} is far from disk center and $\mathbf{n}$, the surface normal, is not aligned with the unit vector pointing toward the observer, $\bm{\ell}$. In this case, the modified Green's function is,
\begin{equation}\label{eq:greens_oblique}
    G = \frac{1}{2\pi}\left[\frac{\mathbf{n}\cdot\bm{\ell}}{R} + \frac{(\bm{\ell}\times(\mathbf{n}\times\bm{\ell}))\cdot\mathbf{R}}{R(R + \bm{\ell}\cdot\mathbf{R})} \right]
\end{equation}
where $\mathbf{R}=\mathbf{r} - \mathbf{r}^\prime$. Note that if $\bm{\ell}=\mathbf{n}$, \autoref{eq:greens_oblique} reduces to \autoref{eq:greens}. The second term in \autoref{eq:greens_oblique} corresponds to a line of dipoles extending out to $z\to\infty$ in order to compensate for a reduction in the first term due to the projection of $\mathbf{n}$ on $\bm{\ell}$ \citep{sakurai_greens_1982}.

The oblique extrapolation method of \citet{schmidt_observable_1964} is implemented in synthesizAR and can easily be used to compute $\mathbf{B}$ above an \AR{},
% spell-checker: disable %
\begin{pycode}[chapter4]
m_ar = magnetogram.submap(l_corner, r_corner)
\end{pycode}
\begin{pyblock}[chapter4][baselinestretch=1,xleftmargin=3em]
from synthesizAR.extrapolate import PotentialField
m_ar_resampled = m_ar.resample([100, 100] * u.pixel)
n_z = 100 * u.pixel
w_z = 215 * u.Mm
extrapolator = PotentialField(m_ar_resampled, w_z, n_z)
B_field = extrapolator.extrapolate()
\end{pyblock}
% spell-checker: enable %
\pyb[chapter4]|m_ar| is a \pyb[chapter4]|Map| object provided by SunPy that includes both the data and associated metadata of the HMI LOS magnetogram cropped to the area around NOAA 12733 as shown in the right panel of \autoref{fig:noaa12733-magnetogram}. The magnetogram is resampled to a lower resolution to reduce the computational cost of the field extrapolation. The method call in the last line computes $\mathbf{B}$ using the Green's function in \autoref{eq:greens_oblique} and the observed magnetogram as $B_z(x,y,0)$ and returns an object containing a $100\times100\times100$ array for each component of $\mathbf{B}$. \autoref{fig:extrapolation-slice} shows a slice along the $y$-axis through the center of the extrapolated volume of $B_x$.

% spell-checker: disable %
\begin{pycode}[chapter4]
# Extract yt dataset and grid
ds = extrapolator.as_yt(B_field)
sli = ds.slice('y', ds.domain_left_edge[1].value+ds.domain_width[1].value/2)
frb = sli.to_frb(ds.domain_width[0], ds.domain_dimensions[[0,2]])
x,z = np.meshgrid(
    np.linspace(
        ds.domain_left_edge[0].value,
        ds.domain_right_edge[0].value,
        ds.domain_dimensions[0]),
    np.linspace(
        ds.domain_left_edge[2].value,
        ds.domain_right_edge[2].value,
        ds.domain_dimensions[2])
)
x = x*u.cm
z = z*u.cm

# Setup figure
fig = plt.figure(figsize=texfigure.figsize(pytex,scale=0.75,height_ratio=0.95,))
ax = fig.gca()
# Plot image
im = ax.pcolormesh(
    x.to(u.Mm), z.to(u.Mm),
    np.array(frb['Bx']).T,
    cmap='better_RdBu_r',
    norm=matplotlib.colors.SymLogNorm(5,vmin=-7.5e2,vmax=7.5e2)
)
# Plot streamlines
ax.streamplot(
    x.to(u.Mm).value, z.to(u.Mm).value,
    np.array(frb['Bx']).T, np.array(frb['Bz']).T,
    color='k', linewidth=1, density=1, arrowstyle='fancy'
)
# Limits and labels
ax.set_xlim(x.to(u.Mm)[0,:][[0,-1]].value)
ax.set_ylim(z.to(u.Mm)[:,0][[0,-1]].value)
ax.set_xlabel(r'$x$ $[\si{\mega\m}]$')
ax.set_ylabel(r'$z$ $[\si{\mega\m}]$')
# Colorbar
pos = ax.get_position().get_points()
cbar = fig.colorbar(
    im,
    fig.add_axes([pos[1,0]+0.01, pos[0,1], 0.03, pos[1,1]-pos[0,1]]),
    orientation='vertical',
)
cbar.locator = matplotlib.ticker.FixedLocator([-1e2, 0, 1e2])
cbar.update_ticks()
# Save figure
tfig = ch4.save_figure('extrapolation-slice', fext='.pdf')
tfig.caption = r'A slice through the center of the extrapolated volume of $B_x$ along the $y$-axis. The black streamlines indicate the $B_x$ and $B_z$ components of the field at this slice. The colorbar is on a log scale and ranges from \SI{-750 }{\gauss} to \SI{750 }{\gauss}.'
tfig.figure_width = r'0.75\textwidth'
\end{pycode}
\py[chapter4]|tfig|
% spell-checker: enable %

Note that both the shape and width of the $z$-dimension in the above code example have units attached to them using the units module, denoted by \pyv{u}, in the Astropy package. The units module provides unit-aware versions of scalar and array quantities as well as the appropriate transformations between units. All inputs and ouputs in synthesizAR which correspond to physical quantities must have units attached. This requirement helps to avoid simple unit conversion errors and allows inputs to be more flexible. The following code snippet shows an example of some of the capabilities of the units module,
% spell-checker: disable %
\begin{pyblock}[chapter4][baselinestretch=1,xleftmargin=3em]
(4e6*u.K).to(u.MK)  # convert from K to MK
10*u.cm/u.s  # units can be combined
1*u.s + 0.5*u.hour  # add compatible units
\end{pyblock}
% spell-checker: enable %

\subsection{Tracing Magnetic Fieldlines}\label{sec:trace-fieldlines}

Now that the vector magnetic field has been computed from the observed LOS magnetogram, the next step in the pipeline is to trace magnetic fieldlines through the extrapolated volume in order to obtain three-dimensional coordinates for each of the magnetic strands. synthesizAR wraps the low-level streamline tracing capabilities of yt, a Python package for manipulating large, high-dimensional datasets \citep{turk_yt_2011}. This is encapsulated in a method attached to the \pyv{PotentialField} object instantiated above,
% spell-checker: disable %
\begin{pyblock}[chapter4][baselinestretch=1,xleftmargin=3em]
strands = extrapolator.trace_fieldlines(
    B_field, 200, loop_length_range=[20,250]*u.Mm)
\end{pyblock}
% spell-checker: enable %
This traces 200 fieldlines through the extrapolated volume and returns a list of field strengths and three-dimensional coordinates along the strand for each of the 200 traced fieldlines. By default, synthesizAR places seed points for the fieldline tracing on the lower boundary in areas of relatively high magnetic field strength though this parameter can be adjusted. Additionally, only strands whose footpoints are both connected to the surface (closed field) and whose loop lengths fall within the specified range (as shown above) are kept.

The last step is to create the magnetic ``skeleton'' object from the traced fieldlines,
% spell-checker: disable %
\begin{pyblock}[chapter4][baselinestretch=1,xleftmargin=3em]
from synthesizAR import Field
noaa12733 = Field(m_ar_resampled, strands)
\end{pyblock}
% spell-checker: enable %
The \pyv{Field} object holds all of the information about each of the magnetic strands. When the \pyv{Field} object is created, a \pyv{Loop} object is created for each strand. These are accessible through the \pyv{.loops} attribute on the \pyv{Field} object. Each \pyv{Loop} object holds several attributes related to the properties of that strand
% spell-checker: disable %
\begin{pyblock}[chapter4][baselinestretch=1,xleftmargin=3em]
noaa12733.loops  # list of all strands
noaa12733.loops[0]  # access the first strand
noaa12733.loops[0].coordinates  # access the 3D positions
noaa12733.loops[0].full_length  # footpoint-to-footpoint length
noaa12733.loops[0].field_strength  # |B| along the streamline
\end{pyblock}
% spell-checker: enable %
This construction provides an intuitive interface for investigating the properties of the \AR{}. \autoref{fig:magnetogram-with-strands} shows all 200 strands traced from the extrapolated volume overlaid on the observed magnetogram of NOAA 12733. 

% spell-checker: disable %
\begin{pycode}[chapter4]
fig = plt.figure(figsize=texfigure.figsize(pytex,scale=0.65,height_ratio=1,))
ax = fig.gca(projection=m_ar)
m_ar.plot(axes=ax, annotate=False, cmap='better_RdBu_r',
          norm=matplotlib.colors.SymLogNorm(50, vmin=-7.5e2, vmax=7.5e2))
ax.grid(alpha=0)
lon,lat = ax.coords[0], ax.coords[1]
lon.set_axislabel('Helioprojective Longitude')
lat.set_axislabel('Helioprojective Latitude')
for l in noaa12733.loops:
    coord = l.coordinates.transform_to(m_ar.coordinate_frame)
    ax.plot_coord(coord, ls='-', lw=1, color='k', alpha=0.5)
tfig = ch4.save_figure('magnetogram-with-strands', fext='.pdf')
tfig.caption = r'LOS magnetogram of NOAA 12733 as observed by SDO/HMI. All 200 traced fieldlines are overlaid in black.'
tfig.figure_width = r'0.65\textwidth'
\end{pycode}
\py[chapter4]|tfig|
% spell-checker: enable %

\subsection{Aside: Coordinate Systems in Solar Physics}\label{sec:coordinates}

The extrapolated magnetic field is represented in a Cartesian coordinate system where the origin is at the center of the \AR{}, the $z$-axis is normal to the surface, and the $y$-axis points toward solar north. The coordinates in this local \AR{} frame can be defined in terms of the Heliocentric Earth equatorial (HEEQ) Cartesian coordinate system of \citet{hapgood_space_1992},
\begin{equation}\label{eq:local_heeq_transform}
    \begin{pmatrix}x_\textup{HEEQ} \\ y_\textup{HEEQ} \\ z_\textup{HEEQ}\end{pmatrix}
    = \mathbf{R}_z(\Phi_\textup{AR})\mathbf{R}_y(-\Theta_\textup{AR})
    \begin{pmatrix}z_\textup{local} \\ x_\textup{local} \\ y_\textup{local}\end{pmatrix},
\end{equation}
where $x_\textup{local}$, $y_\textup{local}$, $z_\textup{local}$ are the coordinates in the local \AR{} frame, $x_\textup{HEEQ}$, $y_\textup{HEEQ}$, $z_\textup{HEEQ}$ are the coordinates in the HEEQ frame, $\mathbf{R}_{y,z}$ are the rotation matrices about the $y$ and $z$ axes, and $\Phi_\textup{AR}$ and $\Theta_\textup{AR}$ are the longitude and latitude of the center of the \AR{}, respectively.

The HEEQ Cartesian coordinate system is defined such that the $z$-axis is the solar rotation axis and increases towards solar north, and the $x$-axis points from the center of the Sun to the intersection between the solar equator and the central meridian as seen from Earth. The longitude and latitude in \autoref{eq:local_heeq_transform} are defined in the Stonyhurst heliographic (HGS) coordinate system which can be defined in HEEQ coordinates as,
\begin{align}\label{eq:heeq_hgs_transform}
    r &= \sqrt{x^2_\textup{HEEQ} + y^2_\textup{HEEQ} + z^2_\textup{HEEQ}}, \\
    \Theta &= \arctan{\left(\frac{z_\textup{HEEQ}}{\sqrt{x^2_\textup{HEEQ} + y^2_\textup{HEEQ}}}\right)}, \\
    \Phi &= \arctan{\left(\frac{y_\textup{HEEQ}}{x_\textup{HEEQ}}\right)},
\end{align}
where $r$ is the radial distance, measured in units of physical distance, from the center of the Sun and $\Phi$ and $\Theta$ are the angles of longitude and latitude, respectively, as measured from origin \citep{thompson_coordinate_2006}. Note that both the HEEQ and HGS coordinate systems are defined such that they remained fixed with respect to the Earth.

% spell-checker: disable %
\begin{pycode}[chapter4]
data = np.zeros((10, 10))
Phi0, B0 = 0*u.deg, -20*u.deg
time_now = astropy.time.Time.now()
meta = {
    'ctype1': 'HPLN-TAN',
    'ctype2': 'HPLT-TAN',
    'cunit1': 'arcsec',
    'cunit2': 'arcsec',
    'crpix1': (data.shape[0] + 1)/2.,
    'crpix2': (data.shape[1] + 1)/2.,
    'cdelt1': 1.0,
    'cdelt2': 1.0,
    'crval1': 0.0,
    'crval2': 0.0,
    'hgln_obs': Phi0.to(u.deg).value,
    'hglt_obs': B0.to(u.deg).value,
    'dsun_obs': const.au.to(u.m).value,
    'dsun_ref': const.au.to(u.m).value,
    'rsun_ref': const.R_sun.to(u.m).value,
    'rsun_obs': ((const.R_sun/const.au).decompose()*u.radian).to(u.arcsec).value,
    't_obs': time_now.iso,
    'date-obs': time_now.iso,
}
dummy_map = GenericMap(data, meta)
# Plot coordinates
fig = plt.figure(figsize=texfigure.figsize(pytex,scale=0.65,height_ratio=1,))
ax = fig.gca(projection=dummy_map)
dummy_map.plot(alpha=0, axes=ax, annotate=False)
ax.plot_coord(
    SkyCoord(*[-1000,-1000]*u.arcsec, frame=dummy_map.coordinate_frame),
    color='w',alpha=0,
)
ax.plot_coord(
    SkyCoord(*[1000,1000]*u.arcsec, frame=dummy_map.coordinate_frame),
    color='w',alpha=0,
)
lon,lat = ax.coords[0],ax.coords[1]
lon.grid(color='k', alpha=0.75, linestyle='solid', lw=1)
lat.grid(color='k', alpha=0.75, linestyle='solid', lw=1)
lon.frame.set_linewidth(0)
lat.frame.set_linewidth(0)
dummy_map.draw_grid(axes=ax, grid_spacing=10*u.deg, color=PALETTE[0], lw=1.5, alpha=0.35)
lon.set_ticks_visible(False)
lat.set_ticks_visible(False)
lon.set_ticks(spacing=250*u.arcsec)
lat.set_ticks(spacing=250*u.arcsec)
lon.set_ticklabel_visible(False)
lat.set_ticklabel_visible(False)
# Save figure
tfig = ch4.save_figure('hpc-hgs-grid', fext='.pdf')
tfig.caption = r'Helioprojective coordinate system (black) overlaid on a Stonyhurst heliographic coordinate system (blue) as viewed by an observer at $(\SI{0}{\degree},\SI{-20}{\degree},\num{1}\,\textup{AU})$. The spacing between the lines of HGS longitude and latitude is \SI{10}{\degree} and the spacing between the lines of HPC longitude and latitude is \SI{250}{\arcsecond}.'
tfig.figure_width = r'0.65\textwidth'
\end{pycode}
\py[chapter4]|tfig|
% spell-checker: enable %

Though the HGS frame provides an intuitive way for representing coordinates on the Sun, real data represent projections of the Sun on the celestial sphere such that the data must be represented in a \textit{projected} coordinate system defined by the position of the observer (e.g. a satellite, Earth). Following \citet{thompson_coordinate_2006}, the helioprojective (HPC) coordinate system is defined in terms of the longitude and latitude on the celestial sphere centered on the Sun-observer line. The transformation between the HPC frame and the heliocentric cartesian (HCC) coordinate frame is given by,
\begin{align}\label{eq:hcc_hpc_transform}
    &d = \sqrt{x^2 + y^2  + (D_{\solar} - z)^2}, \\
    &\theta_x = \arctan{\left(\frac{x}{D_{\solar} - z}\right)}, \\
    &\theta_y = \arcsin{\left(\frac{y}{d}\right)},
\end{align}
where $d$ is the radial distance from the observer, $D_{\solar}$ is the distance between the observer and the center of the Sun, and $x,y,z$ are the coordinates in the HCC frame. The $z$-axis of the HCC frame is oriented along the Sun-observer line and the $y$-axis points toward solar north. The transformation between the HGS and HCC frame is given by,
\begin{align}\label{eq:hgs_hcc_transform}
    &x = r\cos{\Theta}\sin{(\Phi - \Phi_0)}, \\
    &y = r\left( \sin{\Theta}\cos{B_0} - \cos{\Theta}\cos{(\Phi - \Phi_0)}\sin{B_0} \right), \\
    &z = r\left( \sin{\Theta}\sin{B_0} + \cos{\Theta}\cos{(\Phi - \Phi_0)}\cos{B_0} \right),
\end{align}
where $\Phi_0$ and $B_0$ are the HGS longitude and latitude of the observer. Note that unlike the HGS frame, the HPC and HCC frames are defined in terms of an observer at a particular location in HGS coordinates, $(D_{\solar}, \Phi_0, B_0)$. \autoref{fig:hpc-hgs-grid} shows a comparison between the HGS frame and a HPC frame defined by an observer at $\Phi_0=\SI{0}{\degree}$, $B_0=\SI{-20}{\degree}$, and distance of $D_{\solar}=1\,\textup{AU}$.

After the fieldlines are traced through the extrapolated volume, synthesizAR transforms the coordinates into an HEEQ coordinate frame (using \autoref{eq:local_heeq_transform}) and returns an Astropy \pyv{SkyCoord} object for each strand. These are stored in the \pyv{.coordinates} attributed of each \pyv{Loop} object in the magnetic skeleton. A \pyv{SkyCoord} object stores the numerical values of the coordinates as well as the frame of reference in which the coordinates are defined such that coordinates can easily be represented in different frames. SunPy provides representations of and transformations between many of the common solar coordinate systems as described by \citet{thompson_coordinate_2006}. For example, to define a point \pyv{p} on the surface of the Sun at \SI{20}{\degree} longitude and \SI{20}{\degree} latitude and then transform it to a HPC coordinate system defined by an observer on Earth,
% spell-checker: disable %
\begin{pyblock}[][baselinestretch=1,xleftmargin=3em]
from sunpy.coordinates import Helioprojective
p = SkyCoord(lon=20*u.deg, lat=20*u.deg, radius=const.R_sun,
             frame='heliographic_stonyhurst')
hpc_frame = Helioprojective(
    observer='Earth', obstime=astropy.time.Time.now())
p_hpc = p.transform_to(hpc_frame)
\end{pyblock}
% spell-checker: enable %
Representing the coordinates of each strand in this way makes it simple to compute projections of the magnetic skeleton for any viewing angle. For example, in \autoref{fig:magnetogram-with-strands}, the coordinates of each strand are transformed to a HPC coordinate system defined by an observer at the position of the SDO spacecraft on 2019 January 24 14:00:22 UTC. Note that the coordinates of the magnetic strands do not necessarily have to be determined by a magnetic field extrapolation described in \autoref{sec:potential_field}. As long as the coordinates can be expressed in a HGS frame using a \pyv{SkyCoord} object, any method (e.g. a non-linear force-free field extrapolation, see \autoref{sec:field_extrapolation}) may be used to model the magnetic skeleton of the \AR{}.

\section{Field-aligned Modeling}\label{sec:field-aligned-modeling}

After constructing the magnetic skeleton of the \AR{}, the next step in the forward modeling pipeline is to determine the thermal structure of each strand. synthesizAR uses a flexible ``plug-in'' system for specifying how the properties of the strand, such as the loop length and the magnetic field strength, are used to map thermodynamic quantities to the structure of the strand. Several different model \textit{interfaces} are provided by synthesizAR or an interface can be defined by the user and passed to the framework without having to modify the synthesizAR code itself. For example, the following minimal interface maps a single temperature of \SI{2}{\mega\kelvin}, density of \SI{e9}{\per\cubic\cm}, and velocity of \SI{0}{\cm\per\second} to every coordinate of every loop in the \AR{},
% spell-checker: disable %
\begin{pyblock}[][baselinestretch=1,xleftmargin=3em]
class ExampleInterface(object):
    def load_results(self, loop):
        t = u.Quantity([0,], 's')
        T = 2*u.MK * np.ones(
            t.shape+loop.field_aligned_coordinate.shape)
        n = 1e9*u.cm**(-3) * np.ones(T.shape)
        v = 0*u.cm/u.s * np.ones(T.shape)
        return t, T, T, n, v
\end{pyblock}
% spell-checker: enable %
While not very useful, this is a valid model interface. An interface is defined as a Python \pyv{class} with a method called \pyv{load_results} that accepts a \pyv{Loop} object as the single argument. This method then must return the time, electron temperature, ion temperature, density, and velocity as a function of time and coordinate along the field line.

In this example workflow, the thermal structure of each loop is determined using the scaling laws of \citet[see \autoref{sec:scaling_laws}]{martens_scaling_2010}. An interface to the \citeauthor{martens_scaling_2010} scaling laws is included in the synthesizAR package. To define this interface and apply it to each strand in the magnetic skeleton,
% spell-checker: disable %
\begin{pycode}[chapter4]
fn = os.path.join(ch4.data_dir, 'loop_results.h5')
try:
    os.remove(fn)
except OSError:
    pass
\end{pycode}
\begin{pyblock}[chapter4][baselinestretch=1,xleftmargin=3em]
from synthesizAR.interfaces import MartensInterface
martens = MartensInterface()
noaa12733.load_loop_simulations(martens, fn)
\end{pyblock}
% spell-checker: enable %
The maximum temperature of each strand is determined using the scaling laws of \citet{rosner_dynamics_1978} (see \autoref{sec:scaling_laws}) and the base temperature of each strand is fixed at \SI{e4}{\kelvin}. \pyv|fn| specifies the name of the output file for the interface model results. Storing these results on disk rather than in memory is advantageous when constructing an \AR{} with many thousands of loops. After applying the model to each strand, the thermodynamic properties, as a function of loop coordinate and time, can be accessed as attributes on each strand in the \AR{},
% spell-checker: disable %
\begin{pyblock}[chapter4][baselinestretch=1,xleftmargin=3em]
noaa12733.loops[0].time
noaa12733.loops[0].electron_temperature
noaa12733.loops[0].ion_temperature
noaa12733.loops[0].density
\end{pyblock}
% spell-checker: enable %
\autoref{fig:martens-loops} shows the temperature (left panel) and density (right panel) as a function of loop coordinate for all 200 strands in the \AR{} as determined by the scaling laws of \citet{martens_scaling_2010}. Note that it is assumed that the each loop is semi-circular and symmetric about the apex of the strand as the \citeauthor{martens_scaling_2010} scaling laws only model the thermal structure of half of the loop. synthesizAR also includes an interface to the EBTEL model (see \autoref{sec:ebtel}) which I will use in \autoref{ch:modeling_observables} to model the hydrodynamic evolution of many strands in an \AR{} heated by nanoflares.

% spell-checker: disable %
\begin{pycode}[chapter4]
# Setup figure
fig = plt.figure(figsize=texfigure.figsize(pytex,scale=1,height_ratio=1/2,))
ax1 = fig.add_subplot(121,)
ax2 = fig.add_subplot(122,)
# Plot temperature and density
for l in noaa12733.loops:
    ax1.plot(l.field_aligned_coordinate/l.full_length,
             l.electron_temperature.to(u.MK)[0,:],
             color=PALETTE[0], alpha=0.2)
    ax2.plot(l.field_aligned_coordinate/l.full_length,
             l.density[0,:],
             color=PALETTE[0], alpha=0.2)
# Labels and limits
ax1.set_xlabel(r'$s/L$')
ax2.set_xlabel(r'$s/L$')
ax1.set_ylabel(r'$T$ $[\si{\mega\kelvin}]$')
ax2.set_ylabel(r'$n$ $[\si{\per\cubic\cm}]$')
ax2.set_yscale('log')
ax1.set_xlim(0,1)
ax2.set_xlim(0,1)
ax1.set_ylim(0.05,2.2)
plt.subplots_adjust(wspace=0.3)
# Save figure
tfig = ch4.save_figure('martens-loops', fext='.pgf')
tfig.caption = r'Temperature (left) and density (right) as a function of field-aligned coordinate, $s$, normalized to the loop length, $L$, for all 200 strands in the model \AR{} as determined by the scaling laws of \citet{martens_scaling_2010}.'
\end{pycode}
\py[chapter4]|tfig|
% spell-checker: enable %

\section{Atomic Physics}\label{sec:atomic-physics}

% Choose Fe XVIII (94), XVIII (131) XIV (211), and XVI (335)

To correctly model the optically-thin EUV and X-ray emission, synthesizAR uses the CHIANTI atomic database (see \autoref{sec:chianti}) to model the emissivity from all transitions of selected ions for each strand in the magnetic skeleton using \autoref{eq:emissivity_simplified}. The first step is to construct an \pyv{EmissionModel} that includes the relevant ions,
% spell-checker: disable %
\begin{pyblock}[chapter4][baselinestretch=1,xleftmargin=3em]
from fiasco import Ion
T = np.logspace(4, 8, 80) * u.K
kws = { 'abundance_filename': 'sun_coronal_1992_feldman' }
ions = [
    Ion('Fe 8', T, **kws),
    Ion('Fe 14', T, **kws),
    Ion('Fe 16', T, **kws),
    Ion('Fe 18', T, **kws),
]
n = np.logspace(8, 11, 15) * u.cm**(-3)
from synthesizAR.atomic import EmissionModel
em_model = EmissionModel(n, *ions)
\end{pyblock}
% spell-checker: enable %
For this example workflow, I model only a few of the dominant ions in the EUV passbands of AIA: Fe VIII, XIV, XVI, and XVIII. In practice, it is better to include as many ions as possible though this may significantly increase compute times. The ions are specified as \pyv{Ion} objects from the fiasco library, a Python interface to the CHIANTI atomic database. \autoref{ap:fiasco} provides a detailed description of the fiasco package. The ions are then passed to the \pyv{EmissionModel}, a subclass of the fiasco \pyv{IonCollection} obect (see \autoref{sec:ion-collection}). The \pyv{T} and \pyv{n} variables define the grid of temperature and density over which the emissivity is calculated.

After constructing the \pyv{EmissionModel}, the population fraction of each ion specified above is computed for each loop,
% spell-checker: disable %
\begin{pycode}[chapter4]
fn_ionfrac = os.path.join(ch4.data_dir, 'ion_pop.h5')
try:
    os.remove(fn_ionfrac)
except OSError:
    pass
\end{pycode}
\begin{pyblock}[chapter4][baselinestretch=1,xleftmargin=3em]
em_model.calculate_ionization_fraction(noaa12733, fn_ionfrac)
\end{pyblock}
% spell-checker: enable %
The \pyv{.calculate_ionization_fraction} method iterates over each strand in the magnetic skeleton and uses the temperature and density as determined by the field-aligned model (\autoref{sec:field-aligned-modeling}) to compute the population fraction of each ion as a function of the field-aligned coordinate of the strand and store it in the file \pyv{fn_ionfrac}. By default, the population fractions are computed assuming ionization equilibrium (see \autoref{sec:ioneq}) though additional arguments can be passed to \pyv{.calculate_ionization_fraction} to account for time-dependent, out-of-equilibrium charge states (see \autoref{sec:nei}).

Finally, the emissivity is computed for each transition of each ion specified above,
% spell-checker: disable %
\begin{pycode}[chapter4]
fn_emiss = os.path.join(ch4.data_dir, 'emiss_table.h5')
try:
    os.remove(fn_emiss)
except OSError:
    pass
\end{pycode}
\begin{pyblock}[chapter4][baselinestretch=1,xleftmargin=3em]
em_model.calculate_emissivity(fn_emiss)
\end{pyblock}
% spell-checker: enable %
Calculating the level population using \autoref{eq:level_pop} is computationally expensive, particular for ions with many known transitions. \pyv{.calculate_emissivity} computes the product $N_jA_{ji}$ for each transition of each ion over the temperature-density grid defined by \pyv{T} and \pyv{n} and stores it as a look-up table in the file \pyv{fn_emiss}. The emissivity as given by \autoref{eq:emissivity_simplified} can then be efficiently calculated for any loop and transition by looking up the precomputed values for $f_{X,k}$ and $N_jA_{ji}$.

\section{Instrument Effects}\label{sec:instrument-effects}

Now that the magnetic skeleton has been constructed, the thermal structure calculated, and the emissivities tabulated for the relevant ions, the last step in the synthesizAR pipeline is to account for the observing instrument. As in previous steps, the instrument is defined in an object-oriented manner and then passed as an argument,
% spell-checker: disable %
\begin{pyblock}[chapter4][baselinestretch=1,xleftmargin=3em]
from synthesizAR.instruments import InstrumentSDOAIA
aia = InstrumentSDOAIA(
    [0,1]*u.s, noaa12733.magnetogram.observer_coordinate)
from synthesizAR import Observer
observer = Observer(noaa12733, [aia],)
\end{pyblock}
\begin{pycode}[chapter4]
try:
    os.remove(os.path.join(ch4.data_dir, 'SDO_AIA_counts.h5'))
except OSError:
    pass
observer.build_detector_files(ch4.data_dir, 0.05*u.Mm)
\end{pycode}
% spell-checker: enable %
The \pyv{InstrumentSDOAIA} object defines all of the properties of the instrument, including the temporal cadence, the spatial resolution, and the wavelength and temperature response functions for all six of the EUV channels of AIA (see \autoref{sec:aia_response}).

% spell-checker: disable %
\begin{pycode}[chapter4]
dir_results = ch4.data_dir
\end{pycode}
\begin{pyblock}[chapter4][baselinestretch=1,xleftmargin=3em]
observer.flatten_detector_counts(emission_model=em_model)
observer.bin_detector_counts(dir_results)
\end{pyblock}
% spell-checker: enable %

% spell-checker: disable %
\begin{pycode}[chapter4]
fig = plt.figure(figsize=texfigure.figsize(
    pytex,
    scale=1,
    height_ratio=1.01,
    figure_width_context='figurewidth',
))
for i,c in enumerate([94, 131, 211, 335]):
    m = Map(os.path.join(ch4.data_dir, f'SDO_AIA/{c}/map_t000000.fits'))
    m = m.submap(
        SkyCoord(*[-75,125]*u.arcsec, frame=m.coordinate_frame),
        SkyCoord(*[75,275]*u.arcsec, frame=m.coordinate_frame)
    )
    ax = fig.add_subplot(2,2,i+1,projection=m)
    m.plot(
        axes=ax,
        annotate=False,
        norm=ImageNormalize(vmin=0, vmax=m.data.max(),
                            stretch=AsinhStretch(0.01))
    )
    lon, lat = ax.coords[0], ax.coords[1]
    lon.set_ticks(color='w',)
    lat.set_ticks(color='w',)
    lon.frame.set_linewidth(0)
    lat.frame.set_linewidth(0)
    if i != 2:
        lon.set_ticklabel_visible(False)
        lat.set_ticklabel_visible(False)
    else:
        lat.set_ticklabel(rotation='vertical')
        lon.set_axislabel('Helioprojective Longitude')
        lat.set_axislabel('Helioprojective Latitude')
    ax.grid(alpha=0)
    xt,yt = m.world_to_pixel(
        SkyCoord(*[-70,270]*u.arcsec, frame=m.coordinate_frame))
    ax.text(xt.value, yt.value, f'{c} ' + r'\si{\angstrom}', 
            verticalalignment='top', horizontalalignment='left', color='w',
            fontsize=plt.rcParams['legend.fontsize'])
plt.subplots_adjust(wspace=0.02, hspace=0.02)
tfig = ch4.save_figure('aia-intensities', fext='.pdf')
tfig.caption = r'Predicted intensities, in \si{\dn\per\pixel\per\second}, for \AR{} NOAA 12733 as observed by four out of the six AIA EUV channels: \SIlist{94;131;211;335}{\angstrom}. The colorbar is on an $\arcsinh$ scale from 0 to the maximum intensity in that channel and the color tables are the standard AIA color tables as defined in SunPy. The coordinate frame of each map is a helioprojective coordinate system defined by an observer at the location of the SDO satellite on 2019 January 24 14:00:22 UTC.'
\end{pycode}
\py[chapter4]|tfig|
% spell-checker: enable %

% define instrument
% define observer
% interpolate and produce maps as a function of time
% mention PSF, show an alternate observer