% Text for chapter 8
\chapter{Future Work and Conclusions}\label{ch:conclusions}

% spell-checker: disable %
\begin{pycode}[chapter8]
name = 'chapter8'
ch8 = texfigure.Manager(
    pytex,
    os.path.join('.', name),
    number=8,
    **{k: os.path.join('.', name, v) for k,v in manager_opts.items()}
)
from script import spatial_heating_profile
\end{pycode}
% spell-checker: enable %

\section{Conclusions}\label{sec:conclusions}

% outline three results sections and put the bullets there, just paraphrase from those results sections

\section{Future Work}\label{sec:future-work}

% A few more topics:
% - use HYDRAD not EBTEL
% - NLFF field extrapolations
% - additional observables (e.g. doppler shifts)

This work presented in this thesis has made significant progress in understanding the observable signatures of nanoflare heating and placing constraints on the frequency of energy deposition in \AR s. However, a number of improvements remain to be made, particularly in the prescription of the heating model in \autoref{ch:modeling-observables}. The following sections outline several possible improvements.

\subsection{Relating the Heating Frequency to the Magnetic Field Strength}\label{sec:bundle}

The heating model described in \autoref{sec:modeling-observables:heating} parameterizes the heating frequency in terms of a simple ratio $\varepsilon=\frac{\twait}{\tau_\textup{cool}}$ such that $\varepsilon<1$ denotes to high-frequency heating, $\varepsilon\sim1$ denotes intermediate-frequency heating, and $\varepsilon>1$ denotes low-frequency heating. While useful, this prescription leaves $\varepsilon$ as an unconstrained free parameter. However, in the context of the nanoflare model of \citet[see \autoref{sec:nanoflares}]{parker_nanoflares_1988}, the frequency with which field lines reconnect and dissipate their stored energy into the coronal plasma is certainly related to the magnetic field. Thus, the spatial distribution of magnetic flux across an \AR{} provides a potential constraint the heating frequency.

I will now outline a possible method for relating the heating frequency to the observed magnetic field (e.g. from a field extrapolation). First, consider a collection of magnetic strands in an \AR{}, similar to the \num{5e3} traced field lines traced in \autoref{ch:modeling-observables}, whose footpoints all close back at the solar surface. Next, divide up the surface into $n$ equal area boxes and bin the strands into these boxes based on the coordinates of one of their footpoints. This gives $N_\textup{bundles}$ ``bundles'' of strands, where a bundle, $b$, is a collection of strands whose footpoints are in close proximity. Bins with no footpoints are discarded.

Rather than heating each strand individually as in \autoref{ch:modeling-observables}, the strands on each bundle $b$ are heated collectively. This is often referred to as a nanoflare ``storm'' in which each strand in the bundle is heated once in quick succession \citep{klimchuk_key_2015,schmelz_what_2015,mulu-moore_can_2011} such that the strands evolve nearly in-phase. Given a uniform distribution of nanoflare storm onset times $\mathcal{U}(0,t_\textup{total})$, where $t_\textup{total}$ is the total simulation time, $N_\textup{storms}$ onset times are chosen, where $N_\textup{storms}$ is the total number of storms occurring on all bundles in the \AR{}. Each start time $t_s^\textup{start}$ is then assigned to a bundle given the probability,
\begin{equation}
    P_b = \frac{B_b}{\sum_b B_b},
\end{equation}
where $B_b$ is the average field strength of all strands in bundle $b$,
\begin{equation}
    B_b = \frac{\sum_s B_s}{N^\textup{strands}_b},
\end{equation}
and $B_s$ is the coronally-averaged field strength of strand $s$ and $N^\textup{strands}_b$ is the total number of strands in $b$. Thus, \textit{bundles rooted in areas of higher field strength are heated much more frequently}. Additionally, $N_\textup{storms}$ can be chosen by constraining the total energy flux of all bundles over all storms based on observations \citep[e.g. \SI{e7}{\erg\per\square\cm\per\second} from][as in \autoref{sec:modeling-observables:heating}]{withbroe_mass_1977}.

% spell-checker: disable %
\begin{pycode}[chapter8]
channel_pairs = [(94,335), (335,171), (211,193), (171,131)]
correlation_threshold = 0.1
norm = matplotlib.colors.Normalize(vmin=-(5e3*u.s).to(u.s).value,
                                   vmax=(5e3*u.s).to(u.s).value)
plot_params = { 'title': False, 'annotate': False, 'norm': norm, 'cmap': 'idl_bgry_004',}

fig = plt.figure(figsize=texfigure.figsize(
    pytex,
    scale=1,
    height_ratio=1,
))

for i,(ca,cb) in enumerate(channel_pairs):
    m = Map(ch8.data_file(os.path.join('bundle-model', f'timelag_{ca}_{cb}.fits')))
    mc = Map(ch8.data_file(os.path.join('bundle-model', f'correlation_{ca}_{cb}.fits')))
    m = Map(m.data, m.meta, mask=np.where(mc.data<=correlation_threshold, True, False))
    m = m.submap(SkyCoord(Tx=-440*u.arcsec,Ty=-380*u.arcsec,frame=m.coordinate_frame),
                 SkyCoord(Tx=-185*u.arcsec,Ty=-125*u.arcsec,frame=m.coordinate_frame))
    ax = fig.add_subplot(2, 2, i+1, projection=m)
    im = m.plot(axes=ax, **plot_params)
    ax.grid(alpha=0)
    lon = ax.coords[0]
    lat = ax.coords[1]
    if i == 2:
        lat.set_axislabel(r'Helioprojective Latitude',)
        lat.set_ticklabel(rotation='vertical',exclude_overlapping=True)
        lon.set_axislabel(r'Helioprojective Longitude',)
        lon.set_ticklabel(exclude_overlapping=True)
    else:
        lat.set_ticklabel_visible(False)
        lon.set_ticklabel_visible(False)
    xtext,ytext = m.world_to_pixel(SkyCoord(-435*u.arcsec, -130*u.arcsec, frame=m.coordinate_frame))
    ax.text(xtext.value, ytext.value, r'{}-{} $\si{{\angstrom}}$'.format(ca, cb),
            color='k', fontsize=plt.rcParams['legend.fontsize'],
            verticalalignment='top', horizontalalignment='left')
    if i == 0:
        pos = ax.get_position().get_points()
        cbar_x = pos[0,0]
        cbar_y = pos[1,1]+0.01
    if i == 1:
        pos = ax.get_position().get_points()
        cbar_w = pos[1,0] - cbar_x 

# Colorbar
cax = fig.add_axes([cbar_x, cbar_y, cbar_w, 0.02])
cbar = fig.colorbar(im, cax=cax, orientation='horizontal')
cbar.ax.xaxis.set_ticks_position('top')
cbar.ax.tick_params(width=0.5)
cbar.outline.set_linewidth(0.5)

plt.subplots_adjust(wspace=0.025,hspace=0.025)

# Save
tfig = ch8.save_figure('bundle-timelags', fext='.pdf')
tfig.caption = r"Timelag maps produced by the bundle heating model as simulated from a field extrapolation of \AR{} NOAA 1158. A sample of four channel pairs are shown here: 94-335, 335-171, 211-193, and 171-131 \si{\angstrom}. The value of each pixel indicates the temporal offset, in seconds, which maximizes the cross-correlation (see \autoref{eq:timelag}). The range of the colorbar is $\pm\SI{5000}{\second}$. If $\max{\mathcal{C}_{AB}}<0.1$, the pixel is masked and colored white."
\end{pycode}
\py[chapter8]|tfig|
% spell-checker: enable %

This model has two primary advantages compared to the parameterization in \autoref{sec:modeling-observables:heating}: (1) the frequency with which each strand is reenergized is chosen based on the observed field strength rather than being left as a free parameter and (2) nanoflare storms leads to coherent evolution within strands, consistent with the observed collective behavior of loops made up of many strands \citep{klimchuk_key_2015}.

As a proof of concept, I have applied this heating model to the collection of \num{5e3} strands traced from NOAA 1158 as described in \autoref{ch:modeling-observables}. The magnetogram of NOAA 1158 is divided into 50 segments in each direction such that there are 2500 possible bundles though most are empty. The total simulation time is $t_\textup{total}=\SI{3e4}{\second}$ and $N_\textup{storms}$ is constrained such that the average flux through the \AR{} is $\approx\SI{e7}{\erg\per\square\cm\per\second}$.

\autoref{fig:bundle-timelags} shows the resulting timelags in four different channel pairs as computed from the predicted intensities from an \AR{} heated by this bundle model. Notably, the timelags in all channel pairs are more spatially coherent than any of the heating scenarios in \autoref{ch:modeling-observables} (except perhaps the pure cooling model). Detailed comparisons with observations may be needed in order to evaluate the viability of tying the heating frequency directly the magnetic field strength.

\subsection{Thermal Non-equilibrium}\label{sec:tne}

% spell-checker: disable %
\begin{pycode}[chapter8]
# Read in data
i_start,i_stop,i_step = 0,-1,10
with h5py.File(os.path.join(ch8.data_dir, 'hydrad_tne_results.h5'), 'r') as hf:
    t_grid = u.Quantity(hf['time'][i_start:i_stop:i_step],hf['time'].attrs['unit'])
    s_grid = u.Quantity(hf['coordinate'],hf['coordinate'].attrs['unit'])
    Te_grid = u.Quantity(hf['electron_temperature'][i_start:i_stop:i_step,:],
                         hf['electron_temperature'].attrs['unit'])
    Ti_grid = u.Quantity(hf['ion_temperature'][i_start:i_stop:i_step,:],
                         hf['ion_temperature'].attrs['unit'])
    n_grid = u.Quantity(hf['density'][i_start:i_stop:i_step,:],
                        hf['density'].attrs['unit'])
    v_grid = u.Quantity(hf['velocity'][i_start:i_stop:i_step,:],
                        hf['velocity'].attrs['unit'])
\end{pycode}
% spell-checker: enable %

% spell-checker: disable %
\begin{pycode}[chapter8]
h_profile = spatial_heating_profile(s_grid, os.path.join(ch8.data_dir, 'hydrad_tne_config.asdf'))
fig = plt.figure(figsize=texfigure.figsize(
    pytex,
    scale=0.65,
    height_ratio=1,
))
ax = fig.gca()
ax.plot(s_grid.to(u.Mm), h_profile)
ax.set_xlim(s_grid.to(u.Mm)[[0,-1]].value)
ax.set_ylim(0,5.1e-3)
ax.ticklabel_format(axis='y', style='sci', scilimits=(0,0))
ax.set_xlabel(r'$s$ $[\si{\mega\m}]$')
ax.set_ylabel(r'$E_H$ $[\si{\erg\per\cubic\cm\per\second}]$')
tfig = ch8.save_figure('future-work:tne-heating', fext='.pgf')
tfig.caption = r'Heating input as a function of field-aligned coordinate, $s$, for simulating TNE using the HYDRAD code. The full-length of the strand is \SI{120}{\mega\m}. The total heating profile is a combination of two Gaussian heating profiles of width \SI{10}{\mega\m} at the two footpoints, $s=\SI{5}{\mega\m}$ and $s=\SI{115}{\mega\m}$. The heating rates of both pulses \SI{5e-3}{\erg\per\cubic\cm\per\second}. The heating is turned on at $t=\SI{0}{\second}$ and is kept constant for the entire simulation.'
tfig.figure_width = r'0.65\textwidth'
\end{pycode}
\py[chapter8]|tfig|
% spell-checker: enable %

% spell-checker: disable %
\begin{pycode}[chapter8]
# Setup grid
tmesh, smesh = np.meshgrid(s_grid.to(u.Mm), t_grid.to(u.h))
# Setup figure
fig,axes = plt.subplots(2,1,figsize=texfigure.figsize(
    pytex,
    scale=1,
    height_ratio=2/3,
    figure_width_context='figurewidth',)
)
# Temperature
im_T = axes[0].pcolormesh(
    smesh, tmesh, Te_grid.to(u.MK),
    cmap='plasma',
    vmin=0.1,
    vmax=3,
    rasterized=True)
# Density
im_n = axes[1].pcolormesh(
    smesh, tmesh, n_grid,
    cmap='plasma',
    norm=matplotlib.colors.LogNorm(vmin=1e9,vmax=1e10),
    rasterized=True)
# Labels, ticks
axes[0].xaxis.set_major_locator(matplotlib.ticker.NullLocator())
axes[0].yaxis.set_major_locator(matplotlib.ticker.MaxNLocator(nbins=4, prune='lower'))
axes[1].yaxis.set_major_locator(matplotlib.ticker.MaxNLocator(nbins=4,))
axes[1].set_xlabel(r'$t$ $[\si{\hour}]$')
axes[0].set_ylabel(r'$s$ $[\si{\mega\m}]$')
axes[1].set_ylabel(r'$s$ $[\si{\mega\m}]$')
# Colorbars
plt.subplots_adjust(hspace=0.05)
pos = axes[0].get_position().get_points()
cax = fig.add_axes([pos[1,0]+0.005,pos[0,1],0.015,pos[1,1]-pos[0,1]])
cbar = fig.colorbar(im_T, cax=cax, orientation='vertical')
pos = axes[1].get_position().get_points()
cax = fig.add_axes([pos[1,0]+0.005,pos[0,1],0.015,pos[1,1]-pos[0,1]])
cbar = fig.colorbar(im_n, cax=cax, orientation='vertical')
# Save figure
tfig = ch8.save_figure('future-work:tne-results', fext='.pdf')
tfig.caption = r'Electron temperature, in \si{\mega\kelvin} (top), and density, in \si{\per\cubic\cm} (bottom), as a function of field-aligned coordinate, $s$, and time, $t$ as simulated by the HYDRAD code for a semi-circular loop of full-length $L=\SI{120}{\mega\m}$. The time-independent heating function is localized to the footpoints and is shown as a function of $s$ in \autoref{fig:future-work:tne-heating}.'
\end{pycode}
\py[chapter8]|tfig|
% spell-checker: enable %
